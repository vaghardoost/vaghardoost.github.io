{"pageProps":{"note":{"title":"آپاچی کافکا","content":[{"header":"h3","text":"پیشگفتار","id":"f8cbfbe4","type":"title","align":"start"},{"content":[{"content":[{"text":"بین خیلی از سیستم های messageing که توی بازار موجود هست ","style":{"weight":[]}},{"text":"kafka ","style":{"weight":["BOLD"]}},{"text":"احتمالا بهترین گزینه برای این کار بحساب میاد. هرچند گزینه های دیگه ای هم هست که شاید توی بعضی از ویژگی ها از kafka بهتر باشه ولی از نظر تنوع ویژگی و خیلی مسایل دیگه احتمالا kafka بهترین باشه.","style":{"weight":[]}}]}],"id":"e15f348d","type":"caption"},{"header":"h3","text":"یک سناریوی ساده","id":"b2dcf8db","type":"title","align":"start"},{"content":[{"content":[{"text":"معماری میکروسرویس یعنی چند برنامه که با هم هماهنگ هستن و تحت یک بستر به هم پیام میدن.","style":{"weight":[]}}]},{"content":[{"text":"تصور کنید که یک سرور دارید که یک سامانه ی پیچیده هست و ویژگی های زیادی داره. این سامانه از 9 میکروسرویس تشکیل شده که هرکدوم کار یک ویژگی از سرور رو برعهده دارند.","style":{"weight":[]}}]},{"content":[{"text":"عین این 9 تا میکروسرویس باید یک قسمت یا بستر برای ورود و خروج داده هماهنگ با بقیه سرویس ها داشته باشن.حالا اینطوری میشه که 9 تا میکروسرویس هر کدومشون یک سرور rest هستن و بستر تبادل پیامشون این حالت هست.","style":{"weight":[]}}]},{"content":[{"text":"این حالت کلاسیک هست. منسوخ نیست و بقول بعضی از خبره های نرم افزار anti pattern یا ضد الگو نیست. اما ، روش های دیگه ای هم هست. روش هایی که میتونه بعضی حفره های این روش رایجی که گفتم رو پرکنه. برای مثال اگر یک request برای سرویسی که سرش خیلی شلوغ بود بره و هیچ وقت جوابی برنگرده ، احتمال اخلال رو توی کل سامانه ایجاد میکنه.","style":{"weight":[]}}]},{"content":[{"text":"یکی از این روش های دیگه ، وجود یک سرویس مجزا برای تبادل پیام بین سرویس ها هست. سرویسی که بدونه حال و روز سرویس فرستنده و گیرنده چطوریه و آیا مثلا پیام رو دریافت کرده. یا همین سرویس مدیریت پیام ها بین بقیه سرویس ها میتونه از پس تعداد بالایی از پیام های بین سرویس ها بربیاد.","style":{"weight":[]}}]},{"content":[{"text":"یه مثال بین برنامه نویس ها وجود داره که میگه :","style":{"weight":[]}},{"text":"وقت مهمه ، لزومی نداره که برگردیم به 6 هزار سال پیش و چرخ رو دوباره اختراع کنیم. اگر مشکلی که قبلا وجود داشته رو یکی حل کرده خب ما هم راه حل اون رو ادامه میدیم.","style":{"weight":["BOLD"]}}]},{"content":[{"text":"برای messaging بین سرویس ها قبلا نرم افزار هایی ساخته شده. یکی از معروف ترین اون ها ","style":{"weight":[]}},{"text":"Apache Kafka","style":{"weight":["ITALIC","BOLD"]}},{"text":" هست که بقول معروف جز دسته بندی message broker ها یا همون دلال های پیام هست. نرم افزاری که پیام ها رو بین سرویس ها به مدتی که برای تعیین میکنید، آرشیو میکنه. میتونه برای سرویس ها احراز هویت و رمزنگاری پیام ها رو انجام بده و سرعتش به قدری بالاست که میلیون ها پیام رو در مقیاس ثانیه میتونه رد و بدل کنه.","style":{"weight":[]}}]}],"id":"95b63746","type":"caption"},{"header":"h3","text":"معرفی Apache Kafka","id":"ae54db07","type":"title","align":"start"},{"content":[{"content":[{"text":"آپاچی کافکا یک نرم افزار پیامرسان بین نرم افزار های یک سامانه هست. کافکا به زبان جاوا نوشته شده ، قابلیت cluster شدن را دارد و از نرم افزار zookeeper بهره میبرد و میتواند میلیون ها پیام را در بازه ثانیه ارسال و دریافت کند.","style":{"weight":[]}}]},{"content":[{"text":"کافکا یک message broker هست. به این معنا که اگر مبدا پیامی را به مقصد ارسال کند در صورت عدم دریافت پیام توسط مقصد آن پیام منتظر بازگشت مقصد به شبکه کافکا خواهد ماند.","style":{"weight":[]}}]}],"id":"533ece2e","type":"caption"},{"header":"h3","text":"بازدهی و کارایی","id":"8a541b8e","type":"title","align":"start"},{"content":[{"content":[{"text":"نرم افزار های دیگری مشابه کافکا موجود هست که اصلی ترین رقیب کافکا سیستمی به نام rabbitmq هست. کافکا با توجه به الگویی که دارد میتواند میلیون ها پیام را رد و بدل کند درحالی که این رقم برای نرم افزار rabbitmq چیزی حدود 45 هزار پیام بر ثانیه است.اما rabbitmq برای سیستم های پیچیده حالت بهتری را فراهم میکند.","style":{"weight":[]}}]}],"id":"0dc07bf5","type":"caption"},{"header":"h3","text":"ساختار","id":"3e95eec2","type":"title","align":"start"},{"content":[{"content":[{"text":"ساختار کافکا به این شکل هست که برنامه های دیگر یا نرم افزار ها به آن متصل هستند. این نرم افزار ها پیام های خودشان را به در موجودیت هایی به نام ","style":{"weight":[]}},{"text":"topic","style":{"weight":["BOLD"]}},{"text":" قرار میدهند. همچنین سیستم های متصل به شبکه کافکا میتوانند پیام های درج شده در یک topic را دریافت کنند.","style":{"weight":[]}}]},{"content":[{"text":"آن جزء خارجی متصل به شبکه کافکا که بخواهد در تاپیک پیام بگذارد ","style":{"weight":[]}},{"text":"Producer ","style":{"weight":["BOLD"]}},{"text":"یا تامین کننده نام دارد و آن جزء که بخواهد پیام های یک تاپیک را بخواند ","style":{"weight":[]}},{"text":"Consumer","style":{"weight":["BOLD"]}},{"text":" نام دارد.","style":{"weight":[]}}]}],"id":"70f25cf1","type":"caption"},{"header":"h3","text":"معماری میکروسرویس","id":"7b19c85f","type":"title","align":"start"},{"content":[{"content":[{"text":"در معماری میکروسرویس ، گاها یک جز از سیستم برای رساندن یک پیام به جز دیگر از روش های سنتی ای استفاده میکنند که ممکن هست به اقتضای کار متناسب آن کار باشد.","style":{"weight":[]}}]},{"content":[{"text":"برای مثال یک سامانه با ساختار میکروسرویس داریم که قسمت وب سرور آن پیامی را از کاربر خارجی دریافت میکند و برای پردازش باید به سرویس دیگری ارسال کند.","style":{"weight":[]}}]},{"content":[{"text":"یک روش سنتی این کار call کردن هست. به این صورت که هر جز از سیستم باید یک وب سرور باشند و باقی سیستم ها بتوانند از طریق rest برای آنها داده ارسال کنند و منتظر پاسخ باشند.","style":{"weight":[]}}]},{"content":[{"text":"روش کافکا اینطور هست که آن جز از سیستم که api خارجی دارد تامین کننده تاپیک آن جز دیگر سیستم هست که پیام های تاپیک خود را مصرف میکند.","style":{"weight":[]}}]}],"id":"e3e48e43","type":"caption"}],"author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":[],"photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d8cef6a9964af6b53adfc9.png","category":{"label":"مهندسی نرم افزار","author":"645b942ad412792a214b1177","description":"روش های مختلف برنامه نویسی و توسعه نرم افزار","color":"#302d30","avatar":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/demo.64d5f27208efd4d7b4e8abb0.png","namespace":"64ae7b316730ddb96b37c6fb","parent":"64d4ce0abed03dc8b207ba64","id":"64d5eff8983c9b5efb48799c","notes":[{"title":"چرا کارم با جاوا تمام شد","author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":[],"category":"64d5eff8983c9b5efb48799c","photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d8cef3a9964af6b53adfc7.jpeg","id":"64d8ce1442d55f88a06365c5"},{"title":"redis پایگاه داده روی رم","author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":[],"category":"64d5eff8983c9b5efb48799c","photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d8ceefa9964af6b53adfba.png","id":"64d8ce2e42d55f88a06365c7"},{"title":"مثال معماری میکروسرویس","author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":["معماری ","میکروسرویس","نرم افزار"],"category":"64d5eff8983c9b5efb48799c","photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d8cb96a9964af6b53adfa9.jpeg","id":"64d8cb1b42d55f88a06365aa"},{"title":"فرانت را دستکم نگیرید","author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":[],"category":"64d5eff8983c9b5efb48799c","photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d8d1c8a9964af6b53adfcd.jpeg","id":"64d8cdfc42d55f88a06365c3"},{"title":"آپاچی کافکا","author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":[],"photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d8cef6a9964af6b53adfc9.png","category":"64d5eff8983c9b5efb48799c","id":"64d8cdb042d55f88a06365bd"},{"title":"چرا باید از docker  استفاده کرد؟","author":"645b942ad412792a214b1177","namespace":"64ae7b316730ddb96b37c6fb","tag":["داکر","مهندسی نرم افزار","مدیریت اجرا"],"photo":"http://localhost:31375/64ae7b316730ddb96b37c6fb/photo/64d5f29e08efd4d7b4e8abb2.png","category":"64d5eff8983c9b5efb48799c","id":"64d5f7ad983c9b5efb4879a0"}]},"id":"64d8cdb042d55f88a06365bd"}},"__N_SSG":true}